<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
    <script src="js/myModule.js"></script>
    <script src="js/myModule2.js"></script>
</head>
<body>
<script>
    //	1.定义
    function fn1() {
		const a = 2
		const b = 'abc'

		function fn2() {
            console.log(a)
            return fn2
        }
    }

    var fn2r = fn1()
    console.log('当一个嵌套的内部函数引用了嵌套的外部函数的变量时，就产生了闭包')
    console.log('闭包就是这个内部函数的函数对象（不是函数名，函数名是引用）')
    console.log('产生闭包的条件：\n' +
        '1.函数嵌套\n ' +
        '2.内引外\n ' +
        '★3.外部函数被调用一次产生一次（' +
        '外部函数创建执行上下文对象，所有function定义的内部函数被赋值（函数提升），产生闭包。' +
        '和内部函数是否被调用无关！)\n+' +
        '★★★4.外部函数执行完毕后，要有一个引用指向内部函数')
    //	2.常见的闭包
    //将函数作为另一个函数的返回值
    function fn3() {
		let a = 2

		function fn4() {
            a++
            console.log(a)
        }

        return fn4
    }

	const f = fn3()
	// fn3一执行完就被回收了，包括其内的a、fn4，但是
    // ★★★因为f指向了fn4之前指向的函数对象，所以该对象不会被回收
    f()
    f()

    //将函数作为实参传递给另一个函数调用
    function showDelay(msg, time) {
        setTimeout(function () {
            console.log(msg)
        }, time)
    }

    showDelay('精 神 硅 谷 人', 1000)

    console.log(nigger)

    function nigger() {
        console.log('nigger')
    }
    //	3.闭包的生命周期
	console.log('产生：在嵌套的内部函数定义后就产生了')
	console.log('消亡：在该内部函数成为垃圾对象后')

	function fn888() {
		//此时闭包已经产生
		const a = 2

		function fn() {
			console.log(a)
			return fn
		}
	}
	let blackNigger=fn888()
	blackNigger=null

    //  4.闭包の应用：JavaScript的‘模块’
    // let fn=myModule()
    // fn()
    let module=myModule()
    module.slaughterNigger()
    module.slaughterMuGou()

    myModule2.slaughterMuGou()
    myModule2.slaughterNigger()

    //  5.缺点：老不释放内存，容易OOM
    //    解决：用完及时指空

    //  6.面试题
    const name="this window"
    let obj = {
        name:'object',
        getName:function(){
            return function () {
                return this.name
            }
        }
    }
    console.log(obj.getName()())

    const name2="this window"
    let obj2 = {
        name2:'object',
        getName:function(){
            let that=this
            return function () {
                return that.name2
            }
        }
    }
    console.log(obj2.getName()())


</script>
</body>
</html>
